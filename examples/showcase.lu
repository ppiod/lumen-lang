// A trait defines shared behavior, like an interface.
trait Describe {
  fn describe(self) -> String;
}

// A record is used to group data with named fields.
record Character(name: String, level: Integer)

// A sum type defines a type that can have one of several "shapes".
type Action =
  | Attack(Integer)
  | Defend();

// Implements the 'Describe' behavior for our 'Character' record.
impl Describe for Character {
  fn describe(self) -> String {
    $"'{self.name}' is level {self.level}"
  }
}

// Implements the same 'Describe' behavior for the 'Action' sum type.
impl Describe for Action {
  fn describe(self) -> String {
    match self {
      Attack(damage) => $"An attack for {damage} damage!",
      Defend() => "A defensive stance."
    }
  }
}

// A generic function that accepts any type 'T' that implements 'Describe'.
let printDescription = fn<T: Describe>(item: T) {
  item.describe() |> writeln
};

// A recursive function that uses 'when' to create a countdown.
let countdown = fn countdown(n: Integer) -> Null {
  when {
    | (n < 0) => writeln("Blast off!"),
    else => {
      writeln(n);
      countdown(n - 1)
    }
  }
};

// A function that uses array pattern matching to process a list.
let processFirstAction = fn(actions: Array<Action>) -> String {
    match actions {
        [] => "No actions to process.",
        [head, ...tail] => $"Processing: {head.describe()}. Remaining: {len(tail)}."
    }
};

// Declaration of immutable and mutable variables.
let hero = Character("Ryu", 10);
let mut score: Integer = 0;
score += 100;

// Using the generic function with the trait.
printDescription(hero);

// Using an if/else expression to determine a value.
let status = if hero.level > 5 { "Veteran" } else { "Rookie" };
writeln($"Status: {status}");

// Using the pipe operator and lambdas to chain actions.
let action = Attack(99);
action
    |> (act) => act.describe()
    |> (desc) => $"Action confirmed: {desc}."
    |> writeln;

// Calling the recursive function.
writeln("\nRecursive countdown:");
countdown(3);

// Using the function with array pattern matching.
let action_queue: Array<Action> = [Attack(50), Defend()];
processFirstAction(action_queue) |> writeln;


// Tuples are fixed-size, ordered lists that can hold values of different types.
writeln("\n--- Tuples ---");
let player_data: (Integer, String, Boolean) = (1, "Ryu", true);

// They can be destructured with `let`.
let (id, name, isActive) = player_data;
writeln($"Player {name} (ID: {id}) is active: {isActive}.");

// Native string interpolation simplifies formatting strings.
writeln("\n--- String Interpolation ---");
let heroDescription = $"Our hero, {hero.name}, has reached level {hero.level}!";
writeln(heroDescription);
// Combines interpolation with tuple destructuring
let playerDataString = $"Player {name} (ID: {id}) is active: {isActive}.";
writeln(playerDataString);

// The `Result` type is used for operations that can fail.
// It can be either `Ok(value)` for success or `Err(message)` for failure.
writeln("\n--- Error Handling ---");
let safe_divide = fn(a: Integer, b: Integer) -> Result<Integer, String> {
  if b == 0 {
    Err("Cannot divide by zero!")
  } else {
    Ok(a / b)
  }
};

// We use `match` to handle both possibilities safely.
match safe_divide(10, 2) {
  Ok(result) => writeln($"10 / 2 is {result}."),
  Err(msg) => writeln($"Error: {msg}")
};

match safe_divide(10, 0) {
  Ok(result) => writeln($"10 / 0 is {result}."),
  Err(msg) => writeln($"Error from division by zero: {msg}")
};